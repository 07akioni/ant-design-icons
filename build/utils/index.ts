import assert = require('assert');
import chalk from 'chalk';
import { AbstractNode, Node } from '../typings';

export function normalizeNode(node: Node, debugName?: string): AbstractNode {
  const tag = node.tagName;
  if (!tag) {
    throw new TypeError(`${debugName} Element should have no no-tag node`);
  }
  const attrs = node.attrs.reduce((acc, { name, value }) => {
    Object.defineProperty(acc, name, { value, enumerable: true });
    return acc;
  }, {});
  const children = node.childNodes.map((child) =>
    normalizeNode(child, debugName)
  );
  return {
    tag,
    attrs,
    children
  };
}

/**
 * Parse the node generated by parse5 into the abstract tree.
 * @param node the node that need parsing.
 * @param debugName debug name, used in assert statement.
 */
export function generateAbstractTree(
  node: Node,
  debugName?: string
): AbstractNode {
  assert(node, debugName);
  assert(node.tagName === 'svg', debugName);
  const viewBox = node.attrs.find(({ name }) => name === 'viewBox')!;
  assert(viewBox, debugName);
  const size: number[] = viewBox!.value
    .split(' ')
    .slice(2)
    .map((str) => Number.parseInt(str, 10));
  assert(
    size.length === 2,
    `The size tuple should be [ width, height ], but got [ ${size[0]}, ${
      size[1]
    } ] [${debugName}]`
  );
  const oneLevelPathNodes = node.childNodes.filter(
    ({ nodeName, childNodes }) =>
      nodeName !== 'style' && childNodes.length === 0
  );
  assert(oneLevelPathNodes.length >= 1, debugName);

  return normalizeNode(node, debugName);
}

export const log = {
  info(message: string) {
    return console.log(chalk.green(`ðŸŒŸ [Generate] ${message}`));
  },
  notice(message: string) {
    return console.log(chalk.blueBright(`ðŸŒŸ [Notice] ${message}`));
  }
};
